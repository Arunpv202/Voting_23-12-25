SMART CONTRACT BUILDING PROMPT
Privacy-Preserving E-Voting System (Private Ethereum Network)

====================================================
OVERVIEW
====================================================

You are required to build the SMART CONTRACT layer for a privacy-preserving
electronic voting system deployed on a PRIVATE Ethereum blockchain
using Clique Proof-of-Authority.

The smart contract acts ONLY as:
- A public bulletin board
- A commitment & result registry
- A verifiable election timeline

All heavy cryptography (ZKPs, DKG, homomorphic encryption) is handled OFF-CHAIN.

====================================================
TECH STACK
====================================================

- Solidity (>=0.8.x)
- Foundry (forge) for development & testing
- Private Ethereum Network (Clique PoA)
- Backend interaction via ethers.js

====================================================
MANDATORY DESIGN RULES
====================================================

1. NO voter identity stored on-chain
2. NO zkSecret, salt, or Merkle witness stored
3. ONLY commitments, ciphertexts, roots, and results on-chain
4. DKG, ZKP, homomorphic ops are OFF-CHAIN
5. Everything scoped by election_id
6. Contract must be auditable, minimal, and deterministic

====================================================
FOUNDATION PROJECT STRUCTURE (FOUNDRY)
====================================================

/evoting-contracts
│
├── foundry.toml
├── src/
│   ├── Faucet.sol
│   ├── ElectionRegistry.sol
│   └── interfaces/
│       └── IElectionRegistry.sol
│
├── script/
│   ├── DeployFaucet.s.sol
│   └── DeployElectionRegistry.s.sol
│
├── test/
│   ├── Faucet.t.sol
│   └── ElectionRegistry.t.sol
│
└── README.md

====================================================
CONTRACT 1: FAUCET.SOL
====================================================

Purpose:
Provide fake ETH to users so they can pay gas fees on a private chain.

State:
- mapping(address => bool) funded
- constant FUND_AMOUNT = 1 ether

Function:
fundUser(address user)

Behavior:
- Only backend signer calls this
- Prevent multiple funding
- Emit event on success

Event:
UserFunded(address user, uint256 amount)

====================================================
CONTRACT 2: ELECTIONREGISTRY.SOL
====================================================

Purpose:
Public registry for elections, encrypted votes, authorities, and results.

----------------------------------------------------
DATA STRUCTURES
----------------------------------------------------

Election:
- electionId (string)
- electionName (string)
- candidateNames (string[])
- startTime (uint256)
- endTime (uint256)
- resultTime (uint256)
- merkleRoot (bytes32)
- electionPublicKey (bytes)
- initialized (bool)
- encryptedTallyPublished (bool)
- resultPublished (bool)

Authority:
- authorityAddress (address)
- publicKey (bytes)
- active (bool)

EncryptedVote:
- ciphertext (bytes)
- ciphertextHash (bytes32)

----------------------------------------------------
STORAGE
----------------------------------------------------

mapping(string => Election) elections
mapping(string => Authority[]) electionAuthorities
mapping(string => EncryptedVote[]) encryptedVotes
mapping(string => bytes) encryptedTallies
mapping(string => mapping(address => bool)) authoritySubmitted

----------------------------------------------------
REQUIRED FUNCTIONS
----------------------------------------------------

1. createElection(...)
2. registerAuthorities(...)
3. setElectionPublicKey(...)
4. setMerkleRoot(...)
5. submitVote(...)
6. publishEncryptedTally(...)
7. submitPartialDecryption(...)
8. publishFinalResult(...)

----------------------------------------------------
EVENTS (MANDATORY)
----------------------------------------------------

ElectionCreated
AuthoritiesRegistered
ElectionPublicKeySet
MerkleRootSet
VoteSubmitted
EncryptedTallyPublished
PartialDecryptionSubmitted
FinalResultPublished

----------------------------------------------------
WHAT MUST STAY OFF-CHAIN
----------------------------------------------------

- zkSecret
- Merkle witness
- ZKP generation & verification
- DKG protocol
- Authority private shares
- Voter identity

====================================================
EVALUATION CRITERIA
====================================================

- Clean Foundry project structure
- Professional naming conventions
- Modular contracts
- Gas-efficient storage
- Deterministic behavior
- All functions testable
- Events emitted correctly
- Compatible with ethers.js backend

====================================================
FINAL GOAL
====================================================

The smart contract must serve as an immutable,
trust-minimized ledger for:
- Election setup
- Voter eligibility commitment (Merkle root)
- Encrypted votes
- Encrypted tally
- Final result

====================================================
END OF PROMPT
====================================================
